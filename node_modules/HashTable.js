"use strict"

exports.HashTable = function(){
	var table = [];

	var loseloseHashCode = function(key){
		var hash = 0;
		for(var i = 0; i < key.length; i++){
			hash += key.charCodeAt(i);
		}
		// 为了得到比较小的数值，会使用hash值和一个任意数做除法的余数
		return hash % 37;
	};


	this.put = function(key, value){
		var position = loseloseHashCode(key);

		console.log(position + " : " + key);

		table[position] = value;
	};

	this.get = function(key){
		return table[loseloseHashCode(key)];
	};

	this.remove = function(key){
		table[loseloseHashCode(key)] = undefined;
	};
}

//散列表，通过计算hash值来判断key：value位置，顺利情况下，hash表大小是无穷大的，对应计算hash值
// 冲突应该很小的，但是现实中这种情况不存在的！
// 冲突必然，现实中hash表大小无法无限大，那如何解决冲突呢？
// 1.分离链接
// 2.线性探查
// 3.双散列法


// -----------------------------------------------------------------------------------
// 分离链接：为散列表的每一个位置创建一个链表并将元素存储在里面；
// 在HashTable实例之外还需要额外的存储空间
var LinkedList = require("LinkedList");

exports.SeparateChaining = function(){
	var table = [];

	var valuePair = function(key, value){
		this.key = key;
		this.value = value;

		this.toString = function(){
			return "[" + this.key + " - " + this.value + "]";
		}
	};

	var loseloseHashCode = function(key){
		var hash = 0;
		for(var i = 0; i < key.length; i++){
			hash += key.charCodeAt(i);
		}
		// 为了得到比较小的数值，会使用hash值和一个任意数做除法的余数
		return hash % 37;
	};


	this.put = function(key, value){
		var position = loseloseHashCode(key);

		console.log(position + " : " + key);
		if(table[position] == undefined){
			table[position] = new LinkedList();
		}
		table[position].append(new valuePair(key, value));
	};

	this.get = function(key){
		var position = loseloseHashCode(key);
		if(table[position] !== undefined){
			// 遍历链表来寻找键/值
			var current = table[position].getHead();

			while(current.next){
				if(current.element.key === key){
					return current.element.value;
				}
				current = current.next;
			}
			//检查元素在链表第一个或最后一个节点的情况
			if(currrent.element.key === key){
				return current.element.value;
			}
		}

		return undefined;
	};

	this.remove = function(key){
		var position = loseloseHashCode(key);
		if(table[position] !== undefined){
			var current = table[position].getHead();
			while(current.next){
				if(current.element.key === key){
					table[position].remove(current.element);
					if(table[position].isEmpty){
						table[position] = undefined;
					}
					return true;
				}
			}

			if(current.element.key === key){
				table[position].remove(current.element);
				if(table[position].isEmpty()){
					table[position] = undefined;
				}
				return true;
			}
		}
		return false;
	};
}



// -------------------------------------------------------------------
// 线性探查：向hash表中某个位置加入一个新元素的时候，如果索引为index的位置已经被占据了，
// 就尝试index+1的位置。如果index+1的位置也被占据了，继续往下尝试

exports.LinearProbing = function(){
	var table = [];

	var valuePair = function(key, value){
		this.key = key;
		this.value = value;

		this.toString = function(){
			return "[" + this.key + " - " + this.value + "]";
		}
	};

	var loseloseHashCode = function(key){
		var hash = 0;
		for(var i = 0; i < key.length; i++){
			hash += key.charCodeAt(i);
		}
		// 为了得到比较小的数值，会使用hash值和一个任意数做除法的余数
		return hash % 37;
	};

	var djb2HashCode = function(key){
		var hash = 5381;//
		for(var i = 0; i < key.length; i++){
			hash = hash * 33 + key.charCodeAt(i);
		}
		// 为了得到比较小的数值，会使用hash值和一个任意数做除法的余数
		return hash % 1013;
	};


	this.put = function(key, value){
		var position = loseloseHashCode(key);
		//javascript中数组大小会自动变大
		if(table[position] == undefined){
			table[position] = new valuePair(key, value);
		}else{
			var index = ++position;
			while(table[index] != undefined){
				index++;
			}
			table[index] = new valuePair(key, value);
		}
	};

	this.get = function(key){
		var position = loseloseHashCode(key);
		// get方法本质上是遍历数组全部元素（O(n)）
		if(table[position] !== undefined){
			if(table[position].key === key){
				return table[position].value;
			}else{
				var index = ++position;
				while(table[index] === undefined || table[index].key !== key){
					inde++;
				}
				if(table[index].key === key){
					return table[index].value;
				}
			}
		}
		return undefined;
	};

	this.remove = function(key){
		var position = loseloseHashCode(key);
		// get方法本质上是遍历数组全部元素（O(n)）
		if(table[position] !== undefined){
			if(table[position].key === key){
				table[position] = undefined;
			}else{
				var index = ++position;
				while(table[index] === undefined || table[index].key !== key){
					inde++;
				}
				//
				if(table[index].key === key){
					table[position] = undefined;
				}
			}
		}
	};
}