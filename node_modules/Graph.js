// 标识图方式：
// 1.邻接矩阵，每个节点都和一个整数相关联，该整数将作为数组的索引。
// 2.邻接表，由图中每个顶点的相邻顶点列表所组成。
// 3.关联矩阵，矩阵的行表示顶点，列表示边。

"use strict"

var dic = require("Dictionary");
var qu = require("Queue");

exports.Graph = function(){
	var vertices = [];
	var adjList = new dic.Dictionary();


	//向图添加一个新的顶点
	this.addVertex = function(v){
		vertices.push(v);
		adjList.set(v, []);
	};

	//添加顶点之间的边
	this.addEdge = function(v, w){
		// 将w顶点加入到v的邻接表中，添加了一条自顶点v到顶点w的边
		adjList.get(v).push(w);
		//若有向图中，只需要添加上面边，无向图，需添加自w到v的边
		adjList.get(w).push(v);
	};

	// 图遍历：广度优先搜索、深度优先搜索
	// 图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索
	// 1.深度优先搜索，通栈，将顶点存入栈中，顶点式沿着路径被探索的，存在新的相邻顶点就去访问
	// 2.广度优先搜索，通队列，将顶点存入队列中，最先如队列的顶点先被探索


	
	// 广度优先搜索遍历算法
	// 1.创建一个队列Q
	// 2.将v标注为被发现的（灰色），并将v入队列Q
	// 3.如果Q非空，则运行以下步骤
	// 3.1将u从Q中出队列
	// 3.2将标注u为被发现的(灰色)
	// 3.3将u所有未被访问过的领点(白色)入队列
	// 3.4将u标注为已被探索的(黑色)
	var initializeColor = function(){
		var color = [];
		for(var i = 0; i < vertices.length; i++){
			color[vertices[i]] = "white";
		}
		return color;
	};

	this.bfs = function(v, callback){
		var color = initializeColor();//将所有顶点标记为白色（未被探索）
		var	queue = new qu.Queue();
		queue.enqueue(v);

		//
		while(!queue.isEmpty()){
			var u = queue.dequeue();
			var neighbors = adjList.get(u);
			color[u] = "grey";
			for(var i = 0; i < neighbors.length; i++){
				var w = neighbors[i];
				if(color[w] === "white"){
					// 灰色已被发现
					color[w] = "grey";
					queue.enqueue(w);
				}
			}
			// 黑色已被探索
			color[u] = "black";
			if(callback){
				callback(u);
			}
		}
	};

	this.BFS = function(v){
		var color = initializeColor();
		var queue = new qu.Queue();
		var d = [];
		var pred = [];

		queue.enqueue(v);

		// 
		for(var i = 0; i < vertices.length; i++){
			d[vertices[i]] = 0;
			pred[vertices[i]] = null;
		}

		while(!queue.isEmpty()){
			var u = queue.dequeue();
			var neighbors = adjList.get(u);

			color[u] = 'grey';
			for(i = 0;i < neighbors.length; i++){
				var w = neighbors[i];
				if(color[w] === 'white'){
					color[w] = 'grey';
					d[w] = d[u] + 1;
					pred[w] = u;
					queue.enqueue(w);
				}
			}
			color[u] = 'black';
		}

		return{
			distiances : d,
			predecessors:pred
		}
	};

	//
	this.DFS = function(callback){
		var color = initializeColor(),
			d = [],
			f = [],
			p = [];

		// 
		for(var i = 0; i < vertices.length; i++){
			d[vertices[i]] = 0;
			f[vertices[i]] = 0;
			p[vertices[i]] = null;
		}
		// 
		for(var i = 0;i < vertices.lenght; i++){
			if(color[vertices[i]] === 'white'){
				DFSVisit([vertices[i], color, d, f, p);
			}
		}

		return {
			discovery :d,
			finished: f,
			predecessors: p
		};
	};



	var DFSVisit = function(u, color, callback){
		console.log('discovered' + u);
		color[u] = 'grey';
		d[u] = ++time;
		//
		var neighbors = adjList.get(u);
		for(var i = 0; i < neighbors.length; i++){
			var w = neighbors[i];
			if(color[w] === 'white'){
				p[w] = u;
				DFSVisit(w, color, callback);
			}
		}
		color[u] = 'black';
		f[u] = ++time;
		console.log('explored' + u);
	};

	//
	this.printGraph = function(){
		var s = "";

		for(var i = 0; i < vertices.length; i++){
			s += vertices[i] + " -> ";
			var neighbors = adjList.get(vertices[i]);
			for(var j = 0; j < neighbors.length; j++){
				s += neighbors[j] + " ";
			}
			s += "\n";
		}
		return s;
	}
};

exports.printValue = function(value){
	console.log("visited vertex: " + value);
};