// 标识图方式：
// 1.邻接矩阵，每个节点都和一个整数相关联，该整数将作为数组的索引。
// 2.邻接表，由图中每个顶点的相邻顶点列表所组成。
// 3.关联矩阵，矩阵的行表示顶点，列表示边。

"use strict"

var dic = require("Dictionary");
var qu = require("Queue");

exports.Graph = function(){
	var vertices = [];
	var adjList = new dic.Dictionary();


	//向图添加一个新的顶点
	this.addVertex = function(v){
		vertices.push(v);
		adjList.set(v, []);
	};

	//添加顶点之间的边
	this.addEdge = function(v, w){
		// 将w顶点加入到v的邻接表中，添加了一条自顶点v到顶点w的边
		adjList.get(v).push(w);
		//若有向图中，只需要添加上面边，无向图，需添加自w到v的边
		adjList.get(w).push(v);
	};

	// 图遍历：广度优先搜索、深度优先搜索
	// 图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索
	// 1.深度优先搜索，通栈，将顶点存入栈中，顶点式沿着路径被探索的，存在新的相邻顶点就去访问
	// 2.广度优先搜索，通队列，将顶点存入队列中，最先如队列的顶点先被探索


	









	this.printGraph = function(){
		var s = "";

		for(var i = 0; i < vertices.length; i++){
			s += vertices[i] + " -> ";
			var neighbors = adjList.get(vertices[i]);
			for(var j = 0; j < neighbors.length; j++){
				s += neighbors[j] + " ";
			}
			s += "\n";
		}
		return s;
	}
};

