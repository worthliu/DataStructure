// 标识图方式：
// 1.邻接矩阵，每个节点都和一个整数相关联，该整数将作为数组的索引。
// 2.邻接表，由图中每个顶点的相邻顶点列表所组成。
// 3.关联矩阵，矩阵的行表示顶点，列表示边。

"use strict"

var dic = require("Dictionary");
var qu = require("Queue");

exports.Graph = function(){
	var vertices = [];
	var adjList = new dic.Dictionary();


	//向图添加一个新的顶点
	this.addVertex = function(v){
		vertices.push(v);
		adjList.set(v, []);
	};

	//添加顶点之间的边
	this.addEdge = function(v, w){
		// 将w顶点加入到v的邻接表中，添加了一条自顶点v到顶点w的边
		adjList.get(v).push(w);
		//若有向图中，只需要添加上面边，无向图，需添加自w到v的边
		adjList.get(w).push(v);
	};

	// 图遍历：广度优先搜索、深度优先搜索
	// 图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索
	// 1.深度优先搜索，通栈，将顶点存入栈中，顶点式沿着路径被探索的，存在新的相邻顶点就去访问
	// 2.广度优先搜索，通队列，将顶点存入队列中，最先如队列的顶点先被探索


	
	// 广度优先搜索遍历算法
	// 1.创建一个队列Q
	// 2.将v标注为被发现的（灰色），并将v入队列Q
	// 3.如果Q非空，则运行以下步骤
	// 3.1将u从Q中出队列
	// 3.2将标注u为被发现的(灰色)
	// 3.3将u所有未被访问过的领点(白色)入队列
	// 3.4将u标注为已被探索的(黑色)
	var initializeColor = function(){
		var color = [];
		for(var i = 0; i < vertices.length; i++){
			color[vertices[i]] = "white";
		}
		return color;
	};

	this.bfs = function(v, callback){
		var color = initializeColor();
		var	queue = new qu.Queue();
		queue.enqueue(v);

		//
		while(!queue.isEmpty()){
			var u = queue.dequeue();
			var neighbors = adjList.get(u);
			color[u] = "grey";
			for(var i = 0; i < neighbors.lenght; i++){
				var w = neighbors[i];
				if(color[w] === "white"){
					color[w] = "grey";
					queue.enqueue(w);
				}
			}
			color[u] = "black";
			if(callback){
				callback(u);
			}
		}
	};

	//
	this.printGraph = function(){
		var s = "";

		for(var i = 0; i < vertices.length; i++){
			s += vertices[i] + " -> ";
			var neighbors = adjList.get(vertices[i]);
			for(var j = 0; j < neighbors.length; j++){
				s += neighbors[j] + " ";
			}
			s += "\n";
		}
		return s;
	}
};

exports.printValue = function(value){
	console.log("visited vertex: " + value);
};