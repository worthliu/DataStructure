"use strict"

/**
二叉树中的节点，最多只能有两个子节点；
二叉搜索树，它只允许你在左侧节点存储比父节点小的值，在右侧节点存储比父节点大或等于的值
*/
exports.BinarySearchTree = function(){
	var Node = function(key){
		this.key = key;
		this.left = null;
		this.right = null;
	};

	var root = null;

	var insertNode = function(node, newNode){
		if(newNode.key < node.key){
			if(node.left === null){
				node.left = newNode;
			}else{
				insertNode(node.left, newNode);
			}
		}else{
			if(node.right === null){
				node.right = newNode;
			}else{
				insertNode(node.right, newNode);
			}
		}
	};

	this.insert = function(key){
		var newNode = new Node(key);

		if(root === null){
			root = newNode;
		}else{
			insertNode(root, newNode);
		}
	};

	var insertNode = function(node, newNode){
		if(newNode.key < node.key){
			if(node.left === null){
				node.left = newNode;
			}else{
				insertNode(node.left, newNode);
			}
		}else{
			if(node.right === null){
				node.right = newNode;
			}else{
				insertNode(node.right, newNode);
			}
		}
	};


	//中序排序,以根节点为视角
	this.inOrderTraverse = function(callback){
		inOrderTraverseNode(root, callback);
	};

	var inOrderTraverseNode = function(node, callback){
		if(node !== null){
			inOrderTraverseNode(node.left, callback);
			callback(node.key);
			inOrderTraverseNode(node.right, callback);
		}
	};


	//先序排序,以根节点为视角
	this.preOrderTraverse = function(callback){
		preOrderTraverseNode(root, callback);
	};

	var preOrderTraverseNode = function(node, callback){
		if(node !== null){
			callback(node.key);
			preOrderTraverseNode(node.left, callback);
			preOrderTraverseNode(node.right, callback);
		}
	};

	//后序排序,以根节点为视角
	this.postOrderTraverse = function(callback){
		postOrderTraverseNode(root, callback);
	};

	var postOrderTraverseNode = function(node, callback){
		if(node !== null){
			postOrderTraverseNode(node.left, callback);
			postOrderTraverseNode(node.right, callback);
			callback(node.key);
		}
	};

	//
	this.min = function(){
		return minNode(root);
	};

	var minNode = function(node){
		if(node){
			while(node && node.left !== null){
				node = node.left;
			}

			return node.key;
		}
		return null;
	};

	//
	this.max = function(){
		return maxNode(root);
	};

	var maxNode = function(node){
		if(node){
			while(node && node.right !== null){
				node = node.right;
			}

			return node.key;
		}

		return null;
	};

	//
	this.search = function(key){
		return searchNode(root, key);
	};

	var searchNode = function(node, key){
		if(node === null){
			return false;
		}
		//
		if(key < node.key){
			return searchNode(node.left, key);
		}else if(key > node.key){
			return searchNode(node.right, key);
		}else{
			return true;
		}
	};

	//
	this.remove = function(key){
		root = removeNode(root, key);
	};

	var removeNode = function(node, key){
		if(node === null){
			return null;
		}
		//
		if(key < node.key){
			node.left = removeNode(node.left, key);
			return node;
		}else if(key > node.key){
			node.right = removeNode(node.right, key);
			return node;
		}else{
			//1.节点两边都为null，直接去掉
			if(node.left === null && node.right === null){
				node = null;
				return node;
			}
			//2.节点两边有null，直接把不为null的子节点提升到父节点位置
			if(node.left === null){
				node = node.right;
				return node;
			}else if(node.right === null){
				node = node.left;
				return node;
			}
			//3.两个都不为null
			// 3.1找到右边最小的节点
			var aux = findMinNode(node.right);
			// 3.2用右侧最小节点的键去更新这个节点的值
			node.key = aux.key;
			// 3.3将右侧最小节点移除
			node.right = removeNode(node.right, aux.key);
			return node;
		}
	};

}


exports.printValue = function(value){
	console.log(value);
}